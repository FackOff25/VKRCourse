\section{Теоретическая часть}
\subsection{Постановка задачи распределения графа}

Формальная постановка задачи, рассматриваемой в работе, может быть сформулирована следующим образом. Дан граф $G = (V, E)$, где $|V| = n$ - количество вершин, $|E| = m$ - количество рёбер. Распределение графа представляет собой разбиение $P = \{ S_1, S_2, \dots, S_k \}$, где $S_i$ - набор вершин (шард) такой, что $S_i \cap S_j = \emptyset$ для $i \neq j$ и $\bigcup_{i=1}^k S_i = V$.



Требуется найти такое распределение $P^* = \{ S_1^*, S_2^*, \dots, S_k^* \}$, которое:
\begin{enumerate}
    \item Минимизирует общую мощность разрезов:
    \begin{equation}
        |\partial e(P)| = \left| \bigcup_{i=1}^k e(S_i^*, V \setminus S_i^*) \right| \rightarrow \min
    \end{equation}
    или относительную величину:
    \begin{equation}
        \lambda = \frac{|\partial e(P)|}{m} \times 100\% \rightarrow \min
    \end{equation}
    
    \item Минимизирует нормализованную максимальную нагрузку (максимизирует балансировку):
    \begin{equation}
        \rho = \frac{\max_{i=1..k}(|S_i^*|)}{\frac{n}{k}} \rightarrow \min
    \end{equation}
\end{enumerate}

Эта задача относится к классу NP-сложных задач, что обуславливает необходимость использования эвристических подходов, среди которых алгоритм Кернигана-Лина занимает важное место.

\subsection{Методы распределения вершин}

В рамках исследования рассматривались две принципиально различные категории методов решения задачи распределения:

\begin{enumerate}
    \item \textbf{Методы потокового распределения (online partitioning)}: Методы, распределяющие вершину исходя из данных только об уже распределённых вершинах. Эти методы могут быть использованы при изначальном наполнении базы данных.
    
    \item \textbf{Методы оптимизации распределения (offline partitioning)}: Методы распределения графа целиком, которые могут применяться для перераспределения графа по шардам, оптимизируя распределение, полученное методами первой категории.
\end{enumerate}

Алгоритм Кернигана-Лина относится ко второй категории и является методом \emph{уточнения} (refinement) разбиения. Как отмечается в исследовании, методы второй категории более точны и дают лучшие результаты за счёт знания всей структуры графа, но требуют больше вычислительных ресурсов.

В контексте библиотеки METIS (MEtis Tournament Inspired Strategy), которая рассматривается в работе как промышленный стандарт для задач разбиения графов, алгоритм Кернигана-Лина используется на этапе уточнения разбиения в рамках многоуровневой парадигмы.

\subsection{Многоуровневая парадигма и роль алгоритма KL}

Многоуровневая парадигма, лежащая в основе METIS, состоит из трёх этапов:

\begin{enumerate}
    \item \textbf{Свёртка (Coarsening)}: Последовательное уменьшение графа путём схлопывания вершин.
    
    \item \textbf{Распределение (Partitioning)}: Нахождение начального разбиения для сильно свёрнутого графа.
    
    \item \textbf{Развёртка и уточнение (Uncoarsening and Refinement)}: Последовательное восстановление исходного графа с одновременным улучшением разбиения.
\end{enumerate}

На третьем этапе алгоритм Кернигана-Лина играет ключевую роль. 

\subsection{Алгоритм Кернигана-Лина}
Алгоритм Кернигана-Лина (Kernighan-Lin, KL) --- это эвристический алгоритм для задачи разбиения графов на две равные по размеру части с минимальным весом разреза.

\textbf{Постановка задачи}

Пусть дан неориентированный взвешенный граф $G=(V,E)$ с весовой функцией $w: E \rightarrow {R}^+$. Требуется разбить множество вершин $V$ на два непересекающихся подмножества $A$ и $B$ таких, что:
\begin{itemize}
    \item $|A| = |B| = n/2$ (предполагаем, что $n = |V|$ чётно)
    \item Вес разреза минимален: $\min \sum_{a \in A, b \in B, (a,b) \in E} w(a,b)$
\end{itemize}

\textbf{Основные определения}

\begin{itemize}
    \item $P[v]$ --- разбиение, содержащее вершину $v$
    \item Для вершины $v$ определим \textbf{внешнюю стоимость}:
    \[
    E_v = \sum_{\substack{(v,u) \in E \\ P[v] \neq P[u]}} w(v,u)
    \]
    \item \textbf{Внутреннюю стоимость}:
    \[
    I_v = \sum_{\substack{(v,u) \in E \\ P[v] = P[u]}} w(v,u)
    \]
    \item \textbf{Функция улучшения} для вершины $v$ (разность между внешней и внутренней стоимостью):
    \begin{equation}
    g_v = E_v - I_v = \sum_{\substack{(v,u) \in E \\ P[v] \neq P[u]}} w(v,u) - \sum_{\substack{(v,u) \in E \\ P[v] = P[u]}} w(v,u)
    \end{equation}
\end{itemize}

Положительное значение $g_v$ означает, что перемещение вершины $v$ в противоположное разбиение уменьшит вес разреза.

\begin{algorithm}[H]
\caption{Алгоритм Кернигана-Лина}
\begin{algorithmic}[1]
\Require Граф $G=(V,E)$ с весами рёбер, начальное разбиение $(A,B)$
\Ensure Улучшенное разбиение $(A,B)$
\State Инициализация: $\text{улучшение} \gets \text{true}$
\While{$\text{улучшение} = \text{true}$}
    \State $A' \gets A$, $B' \gets B$ \Comment{Рабочие копии}
    \State Рассчитать $g_v$ для всех $v \in V$
    \For{$k \gets 1$ to $n/2$}
        \State Найти пару $(a_k, b_k)$ с максимальным выигрышем:
        \[
        g_k = \max_{\substack{a \in A' \\ b \in B'}} \left[ g_a + g_b - 2w(a,b) \right]
        \]
        где $w(a,b) = 0$, если $(a,b) \notin E$
        \State Пометить $a_k$ и $b_k$ как "заблокированные" (больше не участвуют в выборе на этой итерации)
        \State Обновить значения $g_v$ для соседей $a_k$ и $b_k$:
        \For{каждого соседа $x$ вершины $a_k$}
            \If{$x$ не заблокирован}
                \State $g_x \gets g_x + 2w(a_k,x)$ если $P[x] = P[a_k]$, иначе $g_x \gets g_x - 2w(a_k,x)$
            \EndIf
        \EndFor
        \For{каждого соседа $y$ вершины $b_k$}
            \If{$y$ не заблокирован}
                \State $g_y \gets g_y + 2w(b_k,y)$ если $P[y] = P[b_k]$, иначе $g_y \gets g_y - 2w(b_k,y)$
            \EndIf
        \EndFor
    \EndFor
    \State Найти $m$, максимизирующий частичную сумму:
    \[
    G_m = \max_{1 \leq m \leq n/2} \sum_{i=1}^m g_i
    \]
    \If{$G_m > 0$}
        \State Произвести обмены первых $m$ пар: $(a_1,b_1), \dots, (a_m,b_m)$
        \State $A \gets (A \setminus \{a_1,\dots,a_m\}) \cup \{b_1,\dots,b_m\}$
        \State $B \gets (B \setminus \{b_1,\dots,b_m\}) \cup \{a_1,\dots,a_m\}$
    \Else
        \State $\text{улучшение} \gets \text{false}$ \Comment{Улучшение не найдено}
    \EndIf
\EndWhile
\State \Return $(A,B)$
\end{algorithmic}
\end{algorithm}

\paragraph{Выигрыш от обмена пары вершин}
При обмене вершин $a \in A$ и $b \in B$:
\[
\Delta g(a,b) = g_a + g_b - 2w(a,b)
\]
где:
\begin{itemize}
    \item $g_a + g_b$ --- выигрыш от индивидуального перемещения вершин
    \item $-2w(a,b)$ --- коррекция, так как ребро между $a$ и $b$ (если существует) изменит свой статус: если оно было внутренним, станет внешним, и наоборот
\end{itemize}

\paragraph{Обновление $g_v$ для соседей}
После выбора пары $(a_k, b_k)$ и их блокировки, для соседей этих вершин значения $g$ обновляются:
\begin{itemize}
    \item Для соседа $x$ вершины $a_k$:
    \[
    g_x \gets 
    \begin{cases}
    g_x + 2w(a_k,x), & \text{если } x \text{ находится в том же разбиении, что и } a_k \\
    g_x - 2w(a_k,x), & \text{если } x \text{ находится в противоположном разбиении}
    \end{cases}
    \]
    \item Аналогично для соседей $b_k$
\end{itemize}

\textbf{Сложность алгоритма}

При наивной реализации сложность составляет $O(n^3)$:
\begin{itemize}
    \item Внешний цикл: $O(\text{итераций})$ (Экспериментально было установлено, что хорошая связность достигается уже после 5-10 итераций)
    \item Внутренний цикл по $k$: $O(n/2)$
    \item Поиск оптимальной пары на каждом шаге: $O(n^2)$
    \item Обновление значений $g$: $O(\text{степень вершины})$
\end{itemize}

С оптимизациями можно достичь сложности $O(n^2 \log n)$.

\textbf{Пример работы}

Рассмотрим простой граф из 6 вершин. Начальное разбиение: $A = \{1,2,3\}$, $B = \{4,5,6\}$.

\begin{enumerate}
    \item Рассчитываем $g_v$ для всех вершин
    \item Находим пару с максимальным $\Delta g(a,b)$
    \item Блокируем выбранные вершины, обновляем $g$ для их соседей
    \item Повторяем шаги 2-3, пока все вершины не будут заблокированы
    \item Находим $m$, максимизирующее частичную сумму выигрышей
    \item Если максимальная сумма положительна, производим обмены
\end{enumerate}


\subsubsection{Граничная модификация (BKL)}

Особый интерес представляет граничная модификация алгоритма (Boundary KL - BKL), которая применяет KL только к "граничным" вершинам - тем, которые смежны с вершинами из другого шарда. Как отмечается в работе: "Так как итерации прерываются, большинство вычислений тратятся впустую, особенно в KL(1), поэтому предлагается применять KL только к граничным вершинам. Это позволяет сильно уменьшить вычислительные затраты."

Результаты эксперимента (Таблица 4) показывают, что BKL(1) демонстрирует лучшее соотношение время/качество:
\begin{itemize}
    \item BCSSTK31: $\lambda = 8.08\%$, время выполнения = 0.76
    \item BCSSTK32: $\lambda = 7.31\%$, время выполнения = 0.96
\end{itemize}
